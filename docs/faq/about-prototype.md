# 关于原型的 FAQ

# 所以，如果我想要用 Proto UI 来做事，我需要学习原型怎么编写吗？

不，大概率是不用的！

Proto UI 内置了足够多的原型，目前除了复杂的统计图表类组件外，原型库已有原型能实现常规组件库的全覆盖，所以更推荐用 `src/components/prototype` 下的已有原型

此外，Proto UI 希望能够一劳永逸的解决社区维度的组件库重复建设问题，按照 Proto UI 的设想，当 Proto UI 初具体系之后，只要社区中有人做过类似的原型，你就不需要自己学习原型如何编写。这就和使用 Headless UI 用起来并不需要使用者明白其如何实现一样。

# 为什么不使用 JSON 作为原型的载体，原型本质上不是一种对交互建模的 DSL 语言吗？

这是个很好的问题，根本原因在于 JSON 能承载的内容太结构化，无法承担一些逻辑部分的复用，原型需要一种至少拥有函数的定义、调用能力的语言来作为载体。

此外，原型附着于使用者当前使用的语言，也能利用语言的模块化优势，顺便达成逻辑复用。这样也更能体现，原型是一种建模方式而非具体的语言这一 Proto UI 设计哲学。

# 原型写起来和前端框架有什么区别吗？

写起来很像。

如果你没有前端框架的基础，它的学习成本类似于前端框架；如果你有至少一种前端框架的经验，那么你在语法层面上不会遇到任何阻碍。

虽然原型既不是语言，也不是框架，但是原型致力于抽离那些前端技术方案实践中“公共”的逻辑部分。所以你能在原型的 API 里找到各种各样前端技术的影子。比如说 Web 的 React 和 Vue，原型的 API 有不少借鉴 Web 内优秀前端框架的设计。

# 原型把交互行为划分为了哪些维度？

目前 Prototype 的 API 体现为 7 个维度：

- props：其实语义上更接近 options，指的是可以由设计师、开发者变动的组件参数，例如 Button 的 variant
- state：交互层面上的壮态机，例如 Button 有 hover、focus、active 这样的状态，他们的变动不会重新执行 render 函数，但仍然使视图重绘
- event：交互事件的订阅管理，是组件与最终用户对话的唯一途径，event 根据不同的交互媒介有细致的划分
- view：对于视图中元素的干预（例如获取组件的运行时实例，或实际渲染出来的元素）、对于渲染的干预（强制发起一次视图更新）
- context：如果一个原型，实际上是更复杂的组件的组成部分之一，那么它与这个复杂整体的通信通过 context 进行，在 Proto UI 中，拆分常常是推荐的，所以 context 非常常用
- lifecycle：用于在指定生命周期添加逻辑
- debug：debug 模块专门用于添加对开发者有帮助的提示、警告或者错误，使用 Prototype API 编写的 debug 信息能够映射到不同技术

# Proto UI 的原型，与前端框架的组件有什么显著区别吗？

有 3 个关键的区别：

1. 渲染是手动控制的：原型的任何数据变动都 **不会** 引起视图渲染，所有的渲染都是 **手动** 控制的。这与 MVVM 框架十分不同，原型被要求绝对的可靠、高效、语义通用，故Proto UI 默认并不鼓励自动渲染。

2. state 变化时，有跳过执行渲染函数的高效渲染机制：state 变化仍然可以干预视图渲染，但是 **通常不会** 重新执行 render 函数。以 Web 为例，原型 state 的变化会给渲染的元素添加一个 Attribute，CSS 可以直接命中这些特殊的 Attribute 来进行重绘，这个过程几乎没有 JS 参与，十分高效。其他没有外置样式渲染系统的 GUI 方案，会用其他的方式来进行等效替换，但可以确定的是，state 变化引起的重绘通常比 render 重新执行开销低。

3. 任何有交互的元素，都应该有独立的原型对应，原型强制要求组件按交互主体拆分原型：Proto UI 的原型是强制要求拆分的，拆分原则为：**任何有自己的交互事件的元素** 都应该是一个 **单独的原型**

- 所以 Proto UI 的 Event API 只支持向当前原型对应的根元素添加事件，不支持给子元素添加交互事件
- context 在这种解耦的组件写法里，十分常用，多个组成部分之间的交互完全依赖 context
