# 如何编写一个新的 Adapter？

> **适用于具备平台开发经验的开发者**

如果你熟悉某个平台（如 React / Flutter / Qt），并希望将 Proto UI 的原型系统适配到该平台，那么你来对地方了。

本指南将引导你逐步完成一个 Adapter 的开发过程：从渲染器搭建到生命周期、事件、状态、上下文等模块的实现，逐步建立一个具备完整行为能力的原型运行环境。

我们建议你从最小可运行原型开始，再逐步补全各模块功能，确保每一步行为都能被验证。

---

## 快速开始：跑通第一个原型

我们将用最少的代码构建一个基础渲染 Adapter，验证平台集成是否通畅。

### 步骤 1：创建开发环境

以 React 为例：

```bash
npx create-react-app proto-adapter-demo
```

### 步骤 2：准备测试原型

```ts
const HelloWorld = definePrototype({
  name: 'hello-world',
  setup: () => () => h('div', {}, ['Hello, Proto UI']),
});
```

### 步骤 3：实现最小 Adapter

```ts
export const ReactAdapter = (prototype: Prototype) => {
  const p = {}; // 暂不实现任何模块
  const render = prototype.setup(p);
  const h = (tag, props, children) => React.createElement(tag, props, children);
  return () => render(h);
};
```

### 步骤 4：集成并运行

```tsx
const HelloWorldComponent = ReactAdapter(HelloWorld);

export default function App() {
  return <HelloWorldComponent />;
}
```

若能看到文本 "Hello, Proto UI"，说明 Adapter 框架已成功打通。

---

## 模块列表与职责概览

每个完整的 Adapter 应逐步实现以下模块（推荐实现顺序见右侧优先级）：

| 模块             | 职责简述                              | 推荐顺序 |
| ---------------- | ------------------------------------- | -------- |
| Renderer         | 提供 h 函数，将结构描述转译为平台组件 | ✅ 必须  |
| LifecycleManager | 映射并驱动生命周期事件                | ✅ 必须  |
| EventManager     | 注册与解绑交互事件                    | ✅ 必须  |
| StateManager     | 管理原型状态，投影为样式或装饰状态    | ✅ 必须  |
| ViewManager      | 提供更新调度与根节点访问              | ✅ 必须  |
| PropsManager     | 注入 props，并提供获取与监听机制      | ⚪ 建议  |
| ContextManager   | 实现上下文的提供与订阅机制            | ⚪ 建议  |
| ExposeManager    | 向外暴露原型内部方法                  | ⚪ 可选  |
| DebugManager     | 提供日志输出与可选的调试信息          | ⚪ 可选  |

---

## Renderer：渲染器

Renderer 的职责是提供 `h()` 函数，将原型中描述的结构转译为平台组件。

### 核心 API

```ts
const h: (tag: string, props: Record<string, any>, children: RenderNode[]) => PlatformNode;
```

其中：

- `tag` 表示标签名或平台组件名（如 'div', 'text', 'slot'）
- `props` 是属性字典，可能包含 class/style 等
- `children` 是嵌套的结构描述

### 示例：React 渲染器

```ts
const h = (tag, props, children) => React.createElement(tag, props, children);
```

### 根节点要求

每个原型必须有一个可渲染、可绑定、可样式化的根节点：

- React 中应是 DOM 元素，而非 VNode
- Flutter 中应是 Widget，而非 Element

如需后续模块访问，可在 Adapter 中保留 `getRootElement()`。

### 支持 `slot`

- `h('slot')` 表示插槽位置
- 当前仅支持默认插槽（无命名）

### 样式系统（Styler）

- 若平台不支持 class 属性（如 Flutter），你需实现 class 字符串的解析逻辑

```ts
parseClass('text-zinc-800'); // => { color: '#18181b' }
```

### 注意事项

- h 必须是纯函数
- 不应处理状态逻辑
- 不应绑定事件（交由 EventManager 管理）

---

## LifecycleManager：生命周期系统

### 职责

提供 `p.lifecycle.onMounted()` 等 API，映射至平台组件生命周期。

### 生命周期流程

```text
setup -> create -> mount -> render -> [update]* -> unmount -> destroy
```

你应实现：

- `onMounted(fn)`
- `onUnmounted(fn)`
- 生命周期状态记录与转换检测（如重复 render 报错）

### 特殊机制：预演式 setup

Proto UI 的 `setup()` 会在组件创建前执行，仅用于注册行为（如定义事件、状态），平台需延迟执行这些指令至组件真正挂载时。

推荐构建统一调度中心，由各模块查询当前生命周期状态。

---

## EventManager：事件系统

### 职责

为原型提供事件注册与解绑能力：

```ts
p.event.on(type, handler, options?)
p.event.off(type, handler, options?)
```

- 所有事件默认绑定在根节点上
- 生命周期应绑定在 mounted / unmounted 阶段

### 示例

```ts
p.event.on('click', () => console.log('clicked'));
```

### 不支持的用法

不应在 h 函数中直接绑定事件：

```ts
// 🚫 错误写法
return () => h('div', { onClick: () => {} });
```

---

## StateManager：状态系统

Proto UI 的 state 更像是“属性标签”而非响应式状态。

### 定义状态

```ts
p.state.define('--progress', 0);
p.state.define('data-loading', true);
```

- 值必须为 string/number/boolean
- 名称仅支持 `data-*` 和 `--*`

### 映射建议

- Web 平台：使用 `el.dataset` 与 `el.style.setProperty()`
- 其他平台：由 Styler 模块统一处理

### 监听状态变化（可选）

```ts
p.state.watch('--progress', (v) => console.log(v));
```

官方不推荐原型内部监听自身状态，仅供跨原型数据绑定使用。

---

## ViewManager：视图调度

### 职责

- 提供 `p.view.update()` 与 `p.view.forceUpdate()`
- 提供 `p.view.getElement()` 获取根节点引用

### 示例

```ts
p.view.update(); // 异步更新
p.view.forceUpdate(); // 立即更新

const el = p.view.getElement();
```

注意：`getElement()` 仅可在 mounted 之后调用，setup 中调用应抛错。

---

## PropsManager：参数系统

### API

```ts
p.props.define(key, defaultValue);
p.props.get(key);
p.props.watch(key, callback);
```

- 不自动触发 render，建议用户手动调用 `p.view.update()`
- `define` 可重复定义，若覆盖应警告

---

## ContextManager：上下文系统

用于构建跨原型通信机制，提供如下 API：

```ts
p.context.provide(Context, setupFn);
p.context.watch(Context, callback);
p.context.get(Context);
```

- Context 必须由 `createContext()` 创建
- 向上传播，最近的提供者生效
- 支持中途“遮蔽”上层 Context

---

## ExposeManager：暴露接口

提供向外部公开的方法，例如：

```ts
p.expose.define('show', () => p.state.define('data-visible', true));
```

- 适用于 Toast/Dialog 等受控组件
- 可挂载在组件实例或 ref 上

---

## DebugManager：调试功能

提供调试期日志输出与可选的视觉辅助：

```ts
p.debug.log('render:', p.props.get('label'));
```

可选能力：

- 渲染边界描边
- 生命周期日志
- 渲染次数计数

建议通过环境变量控制启用。

---

## 调试建议与最佳实践

- 每完成一个模块，立即集成并验证
- 为每个模块设计一个测试原型（如 slot、点击测试等）
- 推荐使用 console.log(p) 观察模块结构
- 优先确保“Renderer + Lifecycle + Event”三件套正常工作

---

## 后续可添加段落（待补）：

- 平台适配策略对比（React vs Flutter vs Qt）
- Adapter 常见问题解答（FAQ）
- 提供开发模板与 CLI 工具推荐
- 性能优化建议与调度模型延展

---

## 结语

现在你已具备构建 Proto UI Adapter 的完整起点。

不必一蹴而就 —— 从跑通最小原型开始，逐步引入交互、样式、状态、上下文等模块。

每个平台都有不同的挑战，而这个过程本身，也将成为你深入理解目标平台架构的绝佳方式。

祝你开发顺利。
